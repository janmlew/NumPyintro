# -*- coding: utf-8 -*-
"""DC: Intro to NumPy

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1XEr-EdUlSURYL9_IQ-6LyX9dTxcspaHD

Imports.
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

"""Data apprehension."""

# global variables
# PATH='/content/drive/MyDrive/Colab Notebooks/Project/datasets/' Unnecessary in PyCharm.

# Google Drive mount
# drive.mount('/content/drive', force_remount=True)

# Loads
#   numpy.load(file, mmap_mode=None, allow_pickle=False, fix_imports=True, encoding='ASCII', *, max_header_size=10000)[source]
sudoku_solution = np.load('sudoku_solution.npy', allow_pickle=True)
sudoku_game = np.load('sudoku_game.npy', allow_pickle=True)
monthly_sales = np.load('monthly_sales.npy', allow_pickle=True)
tree_census = np.load('tree_census.npy', allow_pickle=True)
rgb_array = np.load('rgb_array.npy', allow_pickle=True)

"""Understanding NumPy arrays exercises.
* Introducing arrays
* Array dimensionality
* NumPy data types
"""

# Import NumPy
#import numpy as np
sudoku_list=[[0, 0, 4, 3, 0, 0, 2, 0, 9],
             [0, 0, 5, 0, 0, 9, 0, 0, 1],
             [0, 7, 0, 0, 6, 0, 0, 4, 3],
             [0, 0, 6, 0, 0, 2, 0, 8, 7],
             [1, 9, 0, 0, 0, 7, 4, 0, 0],
             [0, 5, 0, 0, 8, 3, 0, 0, 0],
             [6, 0, 0, 0, 0, 0, 1, 0, 5],
             [0, 0, 3, 5, 0, 8, 6, 9, 0],
             [0, 4, 2, 9, 1, 0, 3, 0, 0]]
# Convert sudoku_list into an array
sudoku_array = np.array(sudoku_list)
# Print the type of sudoku_array
print(type(sudoku_array))

# Array with zeros.
zero_array = np.zeros((2, 4))
print(zero_array)
# Array with random numbers between 0 and 1.
random_array = np.random.random((3, 6))
print(random_array.shape)

#y values
doubling_array = np.array([1, 2, 4, 8, 16, 32, 64, 128, 256, 512])
# Create an array of integers from one to ten
one_to_ten = np.arange(1, 11)
# Create your scatterplot
plt.scatter(one_to_ten, doubling_array)
plt.show()

sudoku_game = np.array([[0, 0, 4, 3, 0, 0, 2, 0, 9],
                        [0, 0, 5, 0, 0, 9, 0, 0, 1],
                        [0, 7, 0, 0, 6, 0, 0, 4, 3],
                        [0, 0, 6, 0, 0, 2, 0, 8, 7],
                        [1, 9, 0, 0, 0, 7, 4, 0, 0],
                        [0, 5, 0, 0, 8, 3, 0, 0, 0],
                        [6, 0, 0, 0, 0, 0, 1, 0, 5],
                        [0, 0, 3, 5, 0, 8, 6, 9, 0],
                        [0, 4, 2, 9, 1, 0, 3, 0, 0]])
sudoku_solution = np.array([[8, 6, 4, 3, 7, 1, 2, 5, 9],
                            [3, 2, 5, 8, 4, 9, 7, 6, 1],
                            [9, 7, 1, 2, 6, 5, 8, 4, 3],
                            [4, 3, 6, 1, 9, 2, 5, 8, 7],
                            [1, 9, 8, 6, 5, 7, 4, 3, 2],
                            [2, 5, 7, 4, 8, 3, 9, 1, 6],
                            [6, 8, 9, 7, 3, 4, 1, 2, 5],
                            [7, 1, 3, 5, 2, 8, 6, 9, 4],
                            [5, 4, 2, 9, 1, 6, 3, 7, 8]])
# Create the game_and_solution 3D array
game_and_solution = np.array([sudoku_game, sudoku_solution])
# Print game_and_solution
print(game_and_solution)

new_sudoku_game = np.array([[0, 0, 4, 3, 0, 0, 0, 0, 0],
                            [8, 9, 0, 2, 0, 0, 6, 7, 0],
                            [7, 0, 0, 9, 0, 0, 0, 5, 0],
                            [5, 0, 0, 0, 0, 8, 1, 4, 0],
                            [0, 7, 0, 0, 3, 2, 0, 6, 0],
                            [6, 0, 0, 0, 0, 1, 3, 0, 8],
                            [0, 0, 1, 7, 5, 0, 9, 0, 0],
                            [0, 0, 5, 0, 4, 0, 0, 1, 2],
                            [9, 8, 0, 0, 0, 6, 0, 0, 5]])
new_sudoku_solution = np.array([[2, 5, 4, 3, 6, 7, 8, 9, 1],
                                [8, 9, 3, 2, 1, 5, 6, 7, 4],
                                [7, 1, 6, 9, 8, 4, 2, 5, 3],
                                [5, 3, 2, 6, 9, 8, 1, 4, 7],
                                [1, 7, 8, 4, 3, 2, 5, 6, 9],
                                [6, 4, 9, 5, 7, 1, 3, 2, 8],
                                [4, 2, 1, 7, 5, 3, 9, 8, 6],
                                [3, 6, 5, 8, 4, 9, 7, 1, 2],
                                [9, 8, 7, 1, 2, 6, 4, 3, 5]])
# Create a second 3D array of another game and its solution
new_game_and_solution = np.array([new_sudoku_game, new_sudoku_solution])
# Create a 4D array of both game and solution 3D arrays
games_and_solutions = np.array([game_and_solution, new_game_and_solution])
# Print the shape of your 4D array
print(games_and_solutions.shape)

# Flatten sudoku_game
flattened_game = sudoku_game.flatten()
# Print the shape of flattened_game
print(flattened_game.shape)
# Reshape flattened_game back to a nine by nine array
reshaped_game = flattened_game.reshape((9,9))
# Print sudoku_game and reshaped_game
print(sudoku_game)
print(reshaped_game)

# Create an array of zeros with three rows and two columns
zero_array = np.zeros((3, 2))
# Print the data type of zero_array
print(zero_array.dtype)
# Create a new array of int32 zeros with three rows and two columns
zero_int_array = np.zeros((3, 2), dtype=np.int32)
# Print the data type of zero_int_array
print(zero_int_array.dtype)

# Print the data type of sudoku_game
print(sudoku_game.dtype)
# Change the data type of sudoku_game to int8
small_sudoku_game = sudoku_game.astype(np.int8)
# Print the data type of small_sudoku_game
print(small_sudoku_game.dtype)

"""Selecting and updating data
* Indexing and slicing arrays
"""

# Select all rows of block ID data from the second column
block_ids = tree_census[:, 1]
# Print the first five block_ids
print(block_ids[0:5])
# Select the tenth block ID from block_ids
tenth_block_id = block_ids[9]
print(tenth_block_id)
# Select five block IDs from block_ids starting with the tenth ID
block_id_slice = block_ids[9:14]
print(block_id_slice)

# Create an array of the first 100 trunk diameters from tree_census
hundred_diameters = tree_census[0:100, 2]
print(hundred_diameters)
# Create an array of trunk diameters with *even* row indices from 50 to 100 inclusive
every_other_diameter = tree_census[50:101:2, 2]
print(every_other_diameter)

# Extract trunk diameters information and sort from smallest to largest
sorted_trunk_diameters = np.sort(tree_census[:,2])
print(sorted_trunk_diameters)

"""* Filtering arrays"""

#Lecture code.
#array2d = np.arange(1,21)
#array2d = array2d.reshape(10,2)
#print(array2d[:, 0][array2d[:, 1] % 3 == 0])

# Create an array which contains row data on the largest tree in tree_census
largest_tree_data = tree_census[tree_census[:, 2] == 51]
print(largest_tree_data)
# Slice largest_tree_data to get only the block ID
largest_tree_block_id = largest_tree_data[:, 1]
print(largest_tree_block_id)
# Create an array which contains row data on all trees with largest_tree_block_id
trees_on_largest_tree_block = tree_census[tree_census[:,1]==largest_tree_block_id]
print(trees_on_largest_tree_block)

# Create the block_313879 array containing trees on block 313879
block_313879 = tree_census[tree_census[:,1]==313879]
print(block_313879)
# Create an array of row_indices for trees on block 313879
row_indices = np.where(tree_census[:,1]==313879)
# Create an array which only contains data for trees on block 313879
block_313879 = tree_census[row_indices]
print(block_313879)

# Create and print a 1D array of tree and stump diameters
trunk_stump_diameters = np.where(tree_census[:,2]!=0, tree_census[:,2], tree_census[:,3])
print(trunk_stump_diameters)

"""* Adding and removing data"""

new_trees = np.array([[  1211, 227386,     20,      0],
                      [  1212, 227386,      8,      0]])
# Print the shapes of tree_census and new_trees
print(tree_census.shape, new_trees.shape)
# Add rows to tree_census which contain data for the new trees
updated_tree_census = np.concatenate((tree_census, new_trees))
print(updated_tree_census)

# Print the shapes of tree_census and trunk_stump_diameters
print(trunk_stump_diameters.shape, tree_census.shape)
# Reshape trunk_stump_diameters
reshaped_diameters = trunk_stump_diameters.reshape((1000, 1))
# Concatenate reshaped_diameters to tree_census as the last column
concatenated_tree_census = np.concatenate((tree_census, reshaped_diameters), axis=1)
print(concatenated_tree_census)

# Delete the stump diameter column from tree_census
tree_census_no_stumps = np.delete(tree_census, 3, axis=1)
# Save the indices of the trees on block 313879
private_block_indices = np.where(tree_census[:,1] == 313879)
# Delete the rows for trees on block 313879 from tree_census_no_stumps
tree_census_clean = np.delete(tree_census_no_stumps, private_block_indices, axis=0)
# Print the shape of tree_census_clean
print(tree_census_clean.shape)

"""Array mathematics
* Summarizing data
"""

# Create a 2D array of total monthly sales across industries
monthly_industry_sales = monthly_sales.sum(axis=1, keepdims=True)
print(monthly_industry_sales)
# Add this column as the last column in monthly_sales
monthly_sales_with_total = np.concatenate((monthly_sales, monthly_industry_sales), axis=1)
print(monthly_sales_with_total)

# Create the 1D array avg_monthly_sales
avg_monthly_sales = monthly_sales.mean(axis=1)
print(avg_monthly_sales)
# Plot avg_monthly_sales by month
plt.plot(np.arange(1,13), avg_monthly_sales, label="Average sales across industries")
# Plot department store sales by month
plt.plot(np.arange(1,13), monthly_sales[:,2], label="Department store sales")
plt.legend()
plt.show()

# Find cumulative monthly sales for each industry
cumulative_monthly_industry_sales = monthly_sales.cumsum(axis=0)
print(cumulative_monthly_industry_sales)
# Plot each industry's cumulative sales by month as separate lines
plt.plot(np.arange(1, 13), cumulative_monthly_industry_sales[:, 0], label="Liquor Stores")
plt.plot(np.arange(1, 13), cumulative_monthly_industry_sales[:, 1], label="Restaurants")
plt.plot(np.arange(1, 13), cumulative_monthly_industry_sales[:, 2], label="Department stores")
plt.legend()
plt.show()

"""* Vectorized operations"""

# Create an array of tax collected by industry and month
tax_collected = monthly_sales * 0.05
print(tax_collected)
# Create an array of sales revenue plus tax collected by industry and month
total_tax_and_revenue = tax_collected+monthly_sales
print(total_tax_and_revenue)

monthly_industry_multipliers = np.array([[0.98, 1.02, 1.  ],
                                         [1.00, 1.01, 0.97],
                                         [1.06, 1.03, 0.98],
                                         [1.08, 1.01, 0.98],
                                         [1.08, 0.98, 0.98],
                                         [1.1 , 0.99, 0.99],
                                         [1.12, 1.01, 1.  ],
                                         [1.1 , 1.02, 1.  ],
                                         [1.11, 1.01, 1.01],
                                         [1.08, 0.99, 0.97],
                                         [1.09, 1.  , 1.02],
                                         [1.13, 1.03, 1.02]])
# Create an array of monthly projected sales for all industries
projected_monthly_sales = monthly_sales * monthly_industry_multipliers
print(projected_monthly_sales)
# Graph current liquor store sales and projected liquor store sales by month
plt.plot(np.arange(1,13), monthly_sales[:,0], label="Current liquor store sales")
plt.plot(np.arange(1,13), projected_monthly_sales[:,0], label="Projected liquor store sales")
plt.legend()
plt.show()

names = np.array([["Izzy", "Monica", "Marvin"],
                  ["Weber", "Patel", "Hernandez"]])
# Vectorize the .upper() string method
vectorized_upper = np.vectorize(str.upper)
# Apply vectorized_upper to the names array
uppercase_names = vectorized_upper(names)
print(uppercase_names)

"""* Broadcasting"""

monthly_growth_rate = [1.01, 1.03, 1.03, 1.02, 1.05, 1.03, 1.06, 1.04, 1.03, 1.04, 1.02, 1.01]
# Convert monthly_growth_rate into a NumPy array
monthly_growth_1D = np.array(monthly_growth_rate)
# Reshape monthly_growth_1D
monthly_growth_2D = monthly_growth_1D.reshape(12,1)
# Multiply each column in monthly_sales by monthly_growth_2D
print(monthly_sales*monthly_growth_2D)

# Find the mean sales projection multiplier for each industry
mean_multipliers = monthly_industry_multipliers.mean(axis=0)
print(mean_multipliers)
# Print the shapes of mean_multipliers and monthly_sales
print(mean_multipliers.shape, monthly_sales.shape)
# Multiply each value by the multiplier for that industry
projected_sales = monthly_sales*mean_multipliers
print(projected_sales)

"""Array Transformations
* Saving and loading arrays
"""

"""

DataCamp failed to provide sample image used in the course, so I will generate one.
Target shape is:
(675, 844, 3)

"""

np.random.seed(1)
mystery_image = np.random.randint(1, 156, size=(675, 844, 3))

#Introducing non-random values.
for y in np.arange(0, 675):
  for x in np.arange(0, 844):
    mystery_image[y,x,0] = mystery_image[y,x,0]+(y%100)
    mystery_image[y,x,1] = mystery_image[y,x,1]+(y%50)+(x%50)
    mystery_image[y,x,2] = mystery_image[y,x,2]+(x%100)

with open('mystery_image.npy', 'wb') as f:
  np.save(f, mystery_image)

# Load the mystery_image.npy file
with open('mystery_image.npy', 'rb') as f:
    rgb_array = np.load(f)
plt.imshow(rgb_array)
plt.show()

# Display the documentation for .astype()
print(help(np.ndarray.astype))

# Reduce every value in rgb_array by 50 percent
darker_rgb_array = rgb_array/2
# Convert darker_rgb_array into an array of integers
darker_rgb_int_array = darker_rgb_array.astype(np.int8)
plt.imshow(darker_rgb_int_array)
plt.show()
# Save darker_rgb_int_array to an .npy file called darker_monet.npy
with open('darker_monet.npy', 'wb') as f:
    np.save(f, darker_rgb_int_array)

"""* NumPy acrobatics (whatever that means)."""

# Flip rgb_array so that it is the mirror image of the original
mirrored_monet = np.flip(rgb_array, axis=1)
plt.imshow(mirrored_monet)
plt.show()
# Flip rgb_array so that it is upside down
upside_down_monet = np.flip(rgb_array, axis=(0, 1))
plt.imshow(upside_down_monet)
plt.show()

# Transpose rgb_array
transposed_rgb = np.transpose(rgb_array, axes=(1,0,2))
plt.imshow(transposed_rgb)
plt.show()

"""* Stacking and splitting"""

# Split monthly_sales into quarterly data
q1_sales, q2_sales, q3_sales, q4_sales = np.split(monthly_sales, 4)

# Print q1_sales
print(q1_sales)

# Stack the four quarterly sales arrays
quarterly_sales = np.stack([q1_sales, q2_sales, q3_sales, q4_sales])
print(quarterly_sales)

# Split rgb_array into red, green, and blue arrays
red_array, green_array, blue_array = np.split(rgb_array, 3, axis=2)

# Create emphasized_blue_array
emphasized_blue_array = np.where(blue_array > blue_array.mean(), 255, blue_array)

# Print the shape of emphasized_blue_array
print(emphasized_blue_array.shape)

# Remove the trailing dimension from emphasized_blue_array
emphasized_blue_array_2D = emphasized_blue_array.reshape(675,844)

# Print the shapes of blue_array and emphasized_blue_array_2D
print(blue_array.shape, emphasized_blue_array_2D.shape)

# Reshape red_array and green_array
red_array_2D = red_array.reshape((675, 844))
green_array_2D = green_array.reshape((675, 844))

# Stack red_array_2D, green_array_2D, and emphasized_blue_array_2D
emphasized_blue_monet = np.stack([red_array_2D, green_array_2D, emphasized_blue_array_2D], axis=2)
plt.imshow(emphasized_blue_monet)
plt.show()